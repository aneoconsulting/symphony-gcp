from functools import lru_cache
from logging import Logger
from typing import Any, Dict, List, Optional, Union

from kubernetes import client
from kubernetes.client.rest import ApiException

import gke_provider.k8s.client as k8s_client
from common.utils.profiling import log_execution_time
from gke_provider.config import get_config
from gke_provider.k8s.utils import get_gcpsymphonyresource_phase


@lru_cache(maxsize=1)
def api_client() -> client.ApiClient:
    return k8s_client.get_kubernetes_client()


@lru_cache(maxsize=1)
def custom_obj_api() -> client.CustomObjectsApi:
    return client.CustomObjectsApi(api_client())


@lru_cache(maxsize=1)
def app_client() -> client.AppsV1Api:
    return client.AppsV1Api(api_client())


@lru_cache(maxsize=1)
def core_client() -> client.CoreV1Api:
    return client.CoreV1Api(api_client())


@lru_cache(maxsize=1)
def get_logger() -> Logger:
    return get_config().logger


@lru_cache(maxsize=1)
def get_plural_list() -> List[str]:
    config = get_config()
    return [config.crd_plural, config.crd_return_request_plural]


@log_execution_time(get_logger())
def create_gcpsymphonyresource(
    name_prefix: str,
    count: int,
    pod_spec: dict,
    namespace: str,
    group: str,
    kind: str,
    version: str,
    labels: Optional[dict],
) -> dict[Any, Any]:  # type: ignore
    """
    Create a GCPSymphonyResource.
    """
    config = get_config()
    logger = get_logger()

    resource_body = _create_gcpsr_object_body(
        name_prefix=name_prefix,
        count=count,
        pod_spec=pod_spec,
        namespace=namespace,
        group=group,
        kind=kind,
        version=version,
        labels=labels,
    )

    try:
        api_response = custom_obj_api().create_namespaced_custom_object(
            group=group,
            version=version,
            namespace=namespace,
            plural=config.crd_plural,
            body=resource_body,
        )
        logger.info(f"{kind} created: {api_response}")

    except ApiException as e:
        logger.error(f"Error creating {kind}: {e}")
        raise

    return dict(api_response)


@log_execution_time(get_logger())
def _create_gcpsr_object_body(
    name_prefix: str,
    count: int,
    pod_spec: dict,
    group: str,
    kind: str,
    version: str,
    namespace: str,
    labels: Optional[dict] = None,
    deletePods: Optional[List[str]] = None,
) -> Optional[dict]:
    """
    Create a GCPSymphonyResource object body.
    """
    metadata = {
        # Ensures we have a alpha character at the beginning of the pod name
        "generateName": f"g{name_prefix}-",
        "namespace": namespace,
        "requestId": name_prefix,
        "annotations": {},
        "labels": {},
    }
    if labels:
        metadata["labels"].update(labels)  # type: ignore
        if "metadata" in pod_spec:
            if "annotations" in pod_spec["metadata"]:
                pod_spec["metadata"]["annotations"].update(labels)
            else:
                pod_spec["metadata"]["annotations"] = labels
        else:
            pod_spec["metadata"] = {"annotations": labels}

    config = get_config()
    logger = get_logger()
    logger.debug(f"{config.crd_kind} metadata: {metadata}")
    logger.debug(f"{config.crd_kind} pod_spec: {pod_spec}")

    return {
        "apiVersion": f"{group}/{version}",
        "kind": kind,
        "metadata": metadata,
        "spec": {"namePrefix": name_prefix, "machineCount": count, "podSpec": pod_spec},
    }


@log_execution_time(get_logger())
def create_machine_return_request_body(
    request_id: str,
    machine_ids: List[str],
    namespace: str = get_config().crd_namespace,
    labels: Optional[Dict[str, str]] = None,
) -> Dict[str, Any]:
    """
    Create a object body of a MachineReturnRequest custom resource.

    Args:
        request_id (str): Unique ID generated by the client application for tracking
                          this return request
        machine_ids (List[str]): List of machine IDs (pod names) to return
        namespace (str): The namespace to create the resource in
        labels (Optional[Dict[str, str]]): Optional labels to add to the return request
        target_resource (Optional[str]): Target GCPSymphonyResource name

    Returns:
        Dict[str, Any]: The created MachineReturnRequest resource
    """
    # Add the symphony.requestId label
    if labels is None:
        labels = {}
    labels["symphony.requestId"] = request_id

    config = get_config()
    logger = get_logger()

    resource_body = {
        "apiVersion": f"{config.crd_group}/{config.crd_version}",
        "kind": config.crd_return_request_kind,
        "metadata": {
            "generateName": f"mrr-{request_id}-",
            "namespace": namespace,
            "labels": labels or {},
        },
        "spec": {
            "requestId": request_id,
            "machineIds": machine_ids,
        },
    }

    # Add optional fields if provided
    if labels:
        resource_body["spec"]["labels"] = labels

    logger.debug(f"MachineReturnRequest resource_body: {resource_body}")

    return resource_body


@log_execution_time(get_logger())
def create_machine_return_request_resource(
    request_id: str,
    machine_ids: List[str],
    namespace: str = get_config().crd_namespace,
    group: str = get_config().crd_group,
    version: str = get_config().crd_version,
    labels: Optional[Dict[str, str]] = None,
) -> Dict[str, Any]:
    """
    Create a MachineReturnRequest custom resource on the cluster.

    Args:
        request_id (str): Unique ID generated by the client application for tracking
                          this return request
        machine_ids (List[str]): List of machine IDs (pod names) to return
        namespace (str): The namespace to create the resource in
        group (str): The API group for the custom resource
        version (str): The API version for the custom resource
        labels (Optional[Dict[str, str]]): Optional labels to add to the return request
        target_resource (Optional[str]): Target GCPSymphonyResource name

    Returns:
        Dict[str, Any]: The created MachineReturnRequest resource
    """
    resource_body = create_machine_return_request_body(
        request_id, machine_ids, namespace, labels
    )
    config = get_config()
    logger = get_logger()
    logger.debug(f"MachineReturnRequest resource_body: {resource_body}")

    try:
        api_response = custom_obj_api().create_namespaced_custom_object(
            group=group,
            version=version,
            namespace=namespace,
            plural=config.crd_return_request_plural,
            body=resource_body,
        )
        logger.info(f"MachineReturnRequest created: {api_response}")
        return dict(api_response)
    except ApiException as e:
        logger.error(f"Error creating MachineReturnRequest: {e}")
        raise


@log_execution_time(get_logger())
def _get_resource_from_request_id(
    request_id: str, namespace: str, plural: str = get_config().crd_plural
) -> Optional[Dict[str, Any]]:
    """
    Get the resource name from the request ID.
    This function will handle requests for any custom resource defined by the plural
    variable passed into the function.
    """
    # use the deployment label named symphony.requestId to find the deployment name
    the_item: Optional[dict[str, Any]] = None
    config = get_config()
    logger = get_logger()
    try:
        resource = custom_obj_api().list_namespaced_custom_object(
            namespace=namespace,
            group=config.crd_group,
            version=config.crd_version,
            plural=plural,
            label_selector=f"symphony.requestId={request_id}",
        )
        logger.debug(f"resource is of type {type(resource)} and contains: {resource}")
        if not resource.get("items", []):
            logger.error(
                f"No {plural} found with label symphony.requestId={request_id}"
            )
        elif len(resource.get("items", [])) > 1:
            logger.error(
                f"Multiple {plural} found with label symphony.requestId={request_id}"
            )
        else:
            the_item = resource.get("items", [])[0]
    except ApiException as e:
        logger.error(f"Error getting {plural}: {e}")

    return the_item


@log_execution_time(get_logger())
def _get_resource_name_from_request_id(
    request_id: str, namespace: str, plural: Union[str, None]
) -> Optional[Dict[str, Any]]:
    gcpsr = _get_resource_from_request_id(request_id, namespace, plural)
    if gcpsr is None:
        return None
    return gcpsr["metadata"]["name"]


@log_execution_time(get_logger())
def get_custom_resource_from_request_id(
    request_id: str, namespace: str
) -> Optional[Dict[str, Any]]:
    """
    Get a custom resource from the request ID.
    This function will handle requests for any custom resource defined by plural_list.
    """
    logger = get_logger()
    config = get_config()
    api_response = None
    plural_list = get_plural_list()
    for index, plural in enumerate(plural_list):
        try:
            resource_name = _get_resource_name_from_request_id(
                request_id=request_id, namespace=namespace, plural=plural
            )
            if resource_name is None:
                continue
            api_response = custom_obj_api().get_namespaced_custom_object(
                group=config.crd_group,
                version=config.crd_version,
                namespace=namespace,
                plural=plural,
                name=resource_name,
            )
            logger.debug(f"{plural} retrieved: {api_response}")
            if not isinstance(api_response, dict):
                msg = f"Expected dict for {plural}, got {type(api_response)}: {api_response}"
                logger.error(msg)
                raise TypeError(msg)
        except ApiException as e:
            the_end = len(plural_list) - 1
            if e.status == 404 and index >= the_end:
                logger.info(f"{plural} not found: {e}")
                return None
            elif index >= the_end:
                logger.error(f"Error getting {plural}: {e}")
                raise

    if api_response is not None and not isinstance(api_response, dict):
        raise TypeError(
            f"Expected dict for {plural}, got {type(api_response)}: {api_response}"
        )
    return api_response  # type: ignore


@log_execution_time(get_logger())
def get_pod_list_for_gcpsymphonyresource(resource: Dict[str, Any]):
    logger = get_logger()
    pod_items = []
    try:
        namespace = resource["metadata"]["namespace"]
        requestId = resource["metadata"]["labels"]["symphony.requestId"]
        pod_list = core_client().list_namespaced_pod(
            namespace=namespace, label_selector=f"symphony.requestId={requestId}"
        )

        for pod in pod_list.items:
            if type(pod) is not client.V1Pod:
                logger.debug(f"Expected V1Pod, got {type(pod)}")
                continue
            try:
                pod_items.append(pod.to_dict())
            except Exception as e:
                logger.error(f"Error converting pod to dict: {e}")
                continue
    except ApiException as e:
        logger.error(f"Error getting pod list for GCPSymphonyResource: {e}")
        raise e

    return pod_items


@log_execution_time(get_logger())
def get_resource_status(requestId: str, namespace: str) -> Optional[Dict[str, Any]]:
    """
    Get the status of a custom resource
    This function will handle requests for GCPSymphonyResource and MachineReturnRequest
    """
    config = get_config()
    logger = get_logger()
    pod_items = []
    kind = None
    phase = None
    try:
        # 1. Get the resource from the request ID
        resource = get_custom_resource_from_request_id(requestId, namespace)
        if resource is not None:
            kind = resource.get("kind", "Unknown")
            if kind == config.crd_kind:
                # GCPSymphonyResource found, get the pod_list and check the status
                pod_items = get_pod_list_for_gcpsymphonyresource(resource)
                phase, _ = get_gcpsymphonyresource_phase(
                    requestId,
                    namespace,
                    core_client(),
                    logger,
                    [item["status"]["phase"] for item in pod_items],
                )
            elif kind == config.crd_return_request_kind:
                # MachineReturnRequest - we have all info we need
                phase = resource.get("status", {}).get("phase", "Unknown")
            else:
                no_resource_found = f"No resource found for requestId={requestId}"
                logger.error(no_resource_found)
                phase = {"error": no_resource_found}

    except ApiException as e:
        logger.error(f"Error getting resource: {e}")
        raise e

    return {"kind": kind, "phase": phase, "pods": pod_items}


@log_execution_time(get_logger())
def get_all_gcpsymphonyresources(
    namespace: Optional[str] = None,
) -> Optional[List[Dict[str, Any]]]:
    """
    Get all GCPSymphonyResources.
    """
    config = get_config()
    logger = get_logger()
    try:
        if namespace is not None:
            api_response = custom_obj_api().list_namespaced_custom_object(
                group=config.crd_group,
                version=config.crd_version,
                namespace=namespace,
                plural=config.crd_plural,
            )
            logger.debug(f"GCPSymphonyResources retrieved: {api_response}")
            logger.info(
                f"Found {len(api_response['items'])} "
                f"GCPSymphonyResources in namespace {namespace}"
            )
        else:
            api_response = custom_obj_api().list_cluster_custom_object(
                group=config.crd_group,
                version=config.crd_version,
                plural=config.crd_plural,
            )
        return api_response["items"]
    except ApiException as e:
        logger.error(f"Error getting GCPSymphonyResources: {e}")
        raise
